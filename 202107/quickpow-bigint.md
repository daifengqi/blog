# 快速幂与大整数类型

# QuickPow And BigInt

## 2021 年 7 月 4 日

## Jul 4 2021

### 引言

> 我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。
>
> 比方说，"2582" 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。但 "3245" 不是 好数字，因为 3 在偶数下标处但不是偶数。
> 给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对 10^9 + 7 取余后返回 。
>
> 一个 数字字符串 是每一位都由 0 到 9 组成的字符串，且可能包含前导 0 。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/count-good-numbers

今天周赛，这道题把我整懵了，题目计算过程很简单，关键点有两个，

- 快速幂：因为最大输入长度是`n=10^15`，所以不能`O(n)`地遍历一次，自然要用到快速幂。
- 大整型：因为求幂之后数字比较大，甚至可能超过`2^53`次方，所以要用到ES10新出的`BigInt`数据类型。

下面一一介绍这两个东西。

### 幂运算

说快速幂之前，我们先来看一般的幂运算，即

```javascript
Math.pow(a, b);
```

这种写法是将`a`连着乘了`b`次，就得到`a`的`b`次幂，这个做法的复杂度是`O(n)`的，其中`n=b`。

在`b`很大的时候，这个运算是非常费时间的，明明只是一个简单的幂运算，为什么要这么耗时呢？为了解决这个问题，快速幂就诞生了。

### 快速幂

快速幂的目的是在`O(logn)`的时间复杂度内解决幂运算问题，怎么做呢？看下面这个性质，
$$
a^{2*b}=(a^2)^b
$$
在`b`是**偶数**的情况下（左边），我们可以先计算`a`的平方，再对这个数求`b`次方（右边），这是一个可以无限递归下去的子问题，如果`b`又是偶数，我们可以继续对右边拆分。这样一来，我们其实是在不断把`b`除以2，直到它等于0，这个复杂度是`O(logn`)级别的。

在`b`是**奇数**的情况下呢？我们只用提一个`b`出来，先让`a`把这个`b`乘了，这样又变成了`b`是偶数的问题。

**到此，快速幂的计算过程就呼之欲出了**：只要`b`是偶数，我们就把`b`拆分一半，继续递归，要是`b`是奇数，我们就让`b`减去1的同时把这个`b`乘到`a`上去，把`b`变成偶数，然后还是拆成一半，继续递归。

### 递归

把上面的文字写成代码，就有，

```javascript
function pow(a, b) {
  // 递归结束条件
  if (b === 0) {
    return 1;
  }
  // b是奇数
  if (b & 1) {
    return pow(a, b - 1) * a;
  }
  // b是偶数
  return pow(a * a, Math.floor(b / 2));
}
```

### 循环

也可以用循环的写法，

```js
function pow(a, b) {
  // 幂积
  let res = 1;
  // 不断把b除以2
  for (; b > 0; b >>= 1) {
    // b是奇数，就乘1次a
    if (b & 1) {
      res *= a;
    }
    // 底数不断做平方
    a *= a;
  }
  return res;
}
```

到此为止，我们解决了快速幂的问题。

### 大整数

JavaScript在整数非常大的时候（超过`2^53`）次方，就需要用到大整数类型`BigInt`，关于这个类型，详见[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt)，

简单归纳一下有两个知识点，

1. 大整数的构造

有两种方式赋值一个大整数类型，

```js
let a = BigInt(1000000009) // 方法一：直接使用构造函数
let a = 1000000009n // 方法二：在整数后面加n
```

2. 大整数的运算

大整数类型只能与自身类型做运算，支持的运算类型包括： `+`、``*``、``-``、``**``、``%`` 。（不建议使用位运算）。

### 题解

对于这道题，我们只需要把快速幂改造成支持大整数（`BigInt`）类型的，且支持**取模运算**的函数，就可以解决问题了，如下，

```js
var countGoodNumbers = function(n) {
  	// 模
    const mod = BigInt(1e9 + 7);
  	// 乘了一半的5（剩下的都乘4，n+1是因为奇数的情况是多乘一次5）
    let a = BigInt(Math.floor((n + 1) / 2));
	
  	// 大整数且取模mod的快速幂
    function pow(a, b) {
        if (b === 0n) {
            return 1n;
        }
        if (b % 2n === 1n) {
            return pow(a, b-1n) * a % mod;
        }
        return pow(a*a % mod, b/2n);
    }
	
  // 返回：5的a次幂，乘4的n-a次幂
	return pow(5n, a) * pow(4n, BigInt(n) - a) % mod;
}
```

