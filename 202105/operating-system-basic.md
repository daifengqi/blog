# 操作系统基础知识点汇总

# Operating System From Zero To One

## 2021 年 5 月 10 日

## May 10 2021



### 操作系统

操作系统是软件与硬件的中间层，具有资源调度、内存管理、文件系统、I/O控制等功能。现代操作系统还关注虚拟化和云、分布式、并发和死锁、安全等话题。

从抽象模型的角度来理解OS：

- 文件：对 I/O 设备的抽象
- 虚拟内存：对存储器的抽象
- 进程：对<u>正在运行</u>程序的抽象
- 虚拟机：对整个操作系统的抽象

### Unix中的fork, exec

UNIX里，fork和exec这两个API刚设计出来的时候，**现代操作系统里的进程、线程概念还没有诞生**。

Unix 有三个关于进程的关键 API，`fork()`、`wait()`和 `exec()`，及各种变体。

历史经验表明通过这三个函数来管理进程是最佳实践。

举例来说，对于一个 shell 程序，它允许用户输入某些代码作为程序，shell 程序自身先运行，呈现出画面，然后调用 `fork()`创建新的进程，在`exec()`中传入需要执行的程序及参数，之后调用`wait()`，在输入程序执行结束后，shell 会向屏幕输出提示符。`fork`，`exec`，`wait` 三者分离的思想使得进程可以在三者前后或之间插入自己要执行的代码片段，这使得实现某些功能非常方便，这样的做法也被采纳为最佳实践。

### 进程与线程

**区别：**

- 进程是对运行时程序的封装，**是系统进行资源调度和分配的的基本单位**，实现了操作系统的并发；

- 线程是进程的子任务，更加轻量级，创建和销毁更容易，**是CPU调度和分派的基本单位**，实现进程内部的并发；

- 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；

- 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。

**进程的三种状态：就绪、执行、阻塞**；转换方式如下，

1. 就绪=>运行：调度程序选择一个程序开始运行；
2. 运行=>阻塞：因为I/O操作被阻塞；
3. 阻塞=>就绪：I/O结果返回；
4. 运行=>就绪：调度算法选择另一个进程运行；

**进程的地址空间：**一个进程的地址空间包含运行的程序的所有内存状态。

- 程序的代码（code，指令）。
- 栈（stack）来保存当前的函数调用信息，分配空间给局部变量，传递参数和函数返回值（向上增长）。
- 堆（heap）用于管理动态分配的、用户管理的内存（向下增长）。
- 还有其他的东西（例如，静态初始化的变量）。

**进程的组成部分：**

内存和寄存器。内存是进程的执行指令和数据存放的地方，寄存器则是更小更快的储存。进程的运行过程就是通过不断在很多个寄存器里放入和取出数据和指令。有一些特殊的寄存器，例如，程序计数器（Program Counter，PC）告诉我们程序当前正在执行哪个指令；类似地，栈指针（stack pointer）和相关的帧指针（frame pointer）用于管理函数参数栈、局部变量和返回地址。

进程控制块、或进程列表是一种数据结构，操作系统通过它来跟踪进程的信息。比如进程的上下文（context），进程上下文是所有寄存器状态的集合，当进程切换时，被切换的进程需要把当前上下文保存当内存中的某个位置，以便在切回时取出。

**线程的生命周期（以Java为例）：**

1. 创建状态：使用new实例化一个线程对象，但该线程对象还未使用start()方法启动线程这个阶段，该阶段只在内存的堆中为该对象的实例变量分配了内存空间，但线程还无法参与抢夺CPU的使用权；
2. 就绪状态或正在运行状态：
3. 阻塞状态：睡眠阻塞、挂起阻塞、等待状态；
4. 死亡状态：被GC回收；

### 进程间通信（IPC）：六种机制

注意区别进程间通信和进程同步。

- 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
- 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
- 消息队列：消息队列用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
- 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；
- 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；
- 套接字（Socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

### 进程同步、线程同步

线程同步的方式：

- 互斥量 Synchronized/Lock：互斥锁是最基本的同步形式，用于保护临界区，确保同一时间只有一个线程或进程访问数据或执行其中的代码。互斥量（mutex）本质上是一把锁，访问共享资源前要对互斥量加锁，访问完后要释放锁。互斥量用于上锁，而条件变量用于等待。
- 条件变量：条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定条件发送。条件变量本身是由互斥量保护的。线程在改变条件状态前必须首先锁住互斥量，必须锁住互斥量以后才能计算条件。如果在规定的时间内条件满足就通知线程，否则生成一个代表出错码的返回变量。

- 信号量 Semphare：信号量可用于线程或进程间同步。信号量是一个计数器，用于多进程对共享数据对象的访问。若此信号量的值为正，则进程可以使用该资源；进程将信号量减1，表示它使用了一个资源单元。若此信号量的值为0，则进程进入休眠状态，直至信号量位于0。若一个进程不再使用由一个信号量控制的共享资源时，该信号量值增1。如果有进程正在休眠等待此信号量，则唤醒它们。
- 读写锁：读写锁有三种状态，a. 读模式下加锁状态（所有试图以读模式对其进行加锁的线程都可以获得访问权，但如果试图以写模式加锁，必须阻塞直到所有线程释放读锁）；b. 写模式下加锁状态（在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞）；c. 不加锁状态。可用于进程、线程之间的同步。

### 多进程与多线程

基本思想是进程的创建和开销成本远高于线程，因此高频率创建和销毁的时候要选用多线程。

### 并发

一些概念：

- 竞态条件（race condition）：结果取决于代码的不可控执行顺序。
- 临界区（critical section）：访问共享资源的代码片段。
- 互斥（mutual exclusion）：如果一个线程在临界区内执行，其他线程将被阻止进入临界区。
- 原子性（atomically）：作为一个单元全部执行，或全部不执行。另外，将许多行为组合为单个原子动作称为事务（transaction）。

### 死锁

在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。

死锁产生的四个必要条件：

- 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；

- 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；

- 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放；

- 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系；

### 进程调度策略

- 先进先出（FIFO）：最简单的策略；
- 最短任务优先（SJF，Shortest Job First），将等待中的进程中完成时间最快的优先执行。SJF 是非抢占式的（non-preemptive），这意味着下一个进程的执行总是要等待上一个进程执行结束。但是，现代操作系统中的系统调度方案几乎都是抢占式的。
- 最短完成时间优先（Shortest Time-to-Completion First，STCF）：向SJF添加抢占，每当新工作进入系统时，它就会确定正在执行的进程的剩余工作和新工作中，谁的执行时间最少，然后调度该工作开始执行。

以上三种策略只考虑了周转时间，这是不好的，还需要考虑响应时间（比如键盘输入或鼠标点击必须很快响应）。

- **现代操作系统的调度方法：多级反馈队列（MLFQ）**：
- 规则 1：如果 A 的优先级 > B 的优先级，运行 A（不运行 B）。
- 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。

以上两点是最基础的。

- 规则 3：工作进入系统时，放在最高优先级（最上层队列）。
- 规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。
- 规则 4b：如果工作在其时间片以内主动释放 CPU，则优先级不变。

好处：短周转时间的进程可以立刻被执行（比如打字），而且 I/O 密集型操作会因为主动释放 CPU 而不受到降低优先级的惩罚。

缺点：长进程可能会“饥饿”（进程始终被短进程占用），而且用户可以在程序中加入无关 I/O 操作以欺骗操作系统，从而获得不公平的待遇，优先级始终不会被下调。

- 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。

加入这个规则，保证了长进程不会被饿死，它始终会在最高优先级被轮转执行。

- 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。「该规则覆盖4a和4b」

防止程序欺骗调度系统。

### 用户态和内核态

将原本调用库的过程分离为过程调用（procedure call）和系统调用（system call），后者是前者权限的提升（通常是硬件特权级别）。这样做是出于安全的考虑，过程调用交给用户，系统调用在操作系统内部发生，确保用户的操作不会损害系统。

举例来说，用户程序通常不能发起对磁盘的 I/O 请求，不能访问任何物理内存页或在网络上发送数据包。用户通过 trap（一个特殊硬件指令），将控制权转移给操作系统预先制定的处理程序（trap handler），操作系统在特权级别下执行指令，再通过特殊的返回指令（return-from-trap）将控制权交还给应用程序，同时切换特权级别。

### 孤儿进程、僵尸进程

**孤儿进程：**一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵尸进程：**一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

僵尸进程的解决方法：

1. 通过信号机制：子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。
2. 通过fork两次，将子进程成为孤儿进程，从而其父进程变为init进程，通过init进程可以处理僵尸进程。

### 堆和栈

- 栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
- 堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来方便。

在Windows下，栈是向低地址扩展的，是一块连续的内存的区域。堆是向高地址扩展的数据结构，采用链式存储结构，是不连续的内存区域。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间，因此堆的效率比栈要低的多。

### 虚拟内存

虚拟内存可以比实际上的物理内存大。

见后文「虚拟地址与物理地址」。

### 页面置换算法

- 最优置换策略：替换掉未来最长时间内不再被访问的页面，甚至是未来不会被使用的页。无法实现，因为不知道未来页的访问顺序。
- 先进先出（FIFO）：顾名思义；
- 最少最近使用（LRU，Least recently used ）： 根据页面调入内存的使用情况进行决策，把**最近一段时间最久未使用的页面予以淘汰**。

 LRU算法是较好的一种算法，但由于它要求有较多的硬件支持，故在实际应用中，大多采用LRU的近似算法。Clock算法就是用得较多的一种LRU近似算法。

- 时钟算法（近似LRU）：系统中的所有页都放在一个循环列表中。时钟指针（clock hand）开始时指向某个特定的页。当必须进行页替换时，操作系统检查当前指向的页 P 的使用位是 1 还是 0。如果是 1，则意味着页面 P 最近被使用，因此不适合被替换。然后，P 的使用位设置为 0，时钟指针递增到下一页（P+1）。该算法一直持续到找到一个使用位为 0 的页，使用位为 0 意味着这个页最近没有被使用过（在最坏的情况下，所有的页都已经被使用了，那么就将所有页的使用位都设置为 0）。

时钟算法还可以加入脏页的特性，硬件可以包括一个修改位（modified bit，又名脏位，dirty bit）。扫描到既未使用又干净的页先踢出。无法找到这种页时，再查找未使用的脏页。

### 内存抖动或颠簸

颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。

　　内存颠簸的解决策略包括：

如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；

如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；

否则，还剩下两个办法：终止该进程或增加物理内存容量。

### 虚拟地址与物理地址

任何高级语言打印的地址都是虚拟地址，操作系统不能让用户渗入到真实的物理地址。操作系统使用一个空闲列表记录当前没有使用的物理地址的范围。

在分段的内存管理方式里，从虚拟地址转换到真实地址的公式是虚拟地址加上一个<u>基址（base）</u>，这个过程称为重定位（relocation），基于硬件的重定位称为动态重定位，相较于基于加载软件（loader）的静态重定位，它的优点是提供保护，并且可以在运行时方便地改变地址空间。在动态重定位的过程中，会有一个<u>界限（bound）</u>寄存器来限制进程地址空间的范围。

在分页的模式下，通过为每个进程维护一个页表实现从虚拟地址到物理地址的转换。

### 分段和分页

内部碎片和外部碎片：进程地址空间堆和栈之间未使用的区域称为内部碎片，不同进程地址空间的间隙称为外部碎片。

**分段**是让 CPU 拥有多个基址寄存器与界限寄存器。每一对基址/界限寄存器存有一个段的内容，比如代码段、数据段等，段错误指的是在支持分段的机器上发生了非法的内存访问。在段访问中，我们只需要在虚拟地址的开头加几个二进制比特来标志段，比如 00 代表代码段，01 代表堆地址。由于栈是反向增长的，我们还需要用一个位来表示段的增长方向。还可以提供一些位来增加其它功能，比如保护位（protection bit）用作标志段的读写/共享权限。

**分页**：为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（page table）。页表实现了从虚拟地址到物理地址的映射。页表带来了额外的性能开销，因为每次进程需要访问内存（地址空间）时，都需要先访问页表，再能访问实际的物理地址。

**段没有内部碎片，会产生外部碎片；页没有外部碎片，会产生内部碎片。**

### 垃圾回收算法

1. 引用计数

引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为0则直接回收内存。 

优点：可即刻回收垃圾，速度快。

缺点：浪费CPU资源，高额的时间开销，**且无法克服循环引用**。

2. 标记清除

从根集合出发，将所有活动对象及其子对象打上标记，然后，遍历堆，将非活动对象（未打上标记）的连接到空闲链表上。对象的生死判定使用**可达性分析算法**。（也叫**根搜索算法**，通过一系列的称为 `GC Roots` 的对象作为起点，然后向下搜索。搜索所走过的**路径**称为引用链 （`Reference Chain`）， 当一个**对象**到 `GC Roots` 没有任何**引用链**相连时, 即该对象**不可达**，也就说明此对象是**不可用的**。）

优点：实现简单。

缺点：**效率低**，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用不适用。且**碎片化严重**，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。

对标记清除算法的优化：

标记压缩（标记整理）：在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。然而因为多出了移动这一步，所以有更多的时间开销。

位图标记：使用位图标记，可以减少回收过程中的换页次数

3. 复制算法

这种收集算法解决了标记清除算法存在的效率问题。它将内存区域划分成相同的两个**内存块**。每次仅使用一半的空间，`JVM`生成的新对象放在一半空间中。当一半空间用完时进行`GC`，把可到达对象复制到另一半空间，然后把使用过的内存空间一次清理掉。

4. 分代收集

这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把堆内存分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，考虑到复制成本低，适合采用**复制算法**，只需要付出少量存活对象的复制成本就可以完成。对于**老年代**，因为对象**存活率高**，没有额外的内存空间对它进行担保。因而适合采用**标记-清理算法**或**标记-整理算法**进行回收。