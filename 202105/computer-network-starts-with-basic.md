# 计算机网络基础知识点汇总

# Computer Network From Zero To One

## 2021 年 5 月 6 日

## May 6 2021



### 三次握手

三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。在 socket 编程中，客户端执行 `connect()` 时，将触发三次握手。

1. 第一次握手(SYN=1, seq=x)：客户端发送一个 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号x，保存在头部的序列号(Sequence Number)字段里。

   发送完毕后，客户端进入 `SYN_SEND` 状态。

2. 第二次握手(SYN=1, ACK=1, seq=y, ack=x+1)：服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己初始化ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN加1，即X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

3. 第三次握手(SYN=0，ACK=1，ack=y+1)：客户端再次发送确认包(ACK)，ACK 标志位为1，发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

### 四次挥手

四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作；在 socket 编程中，任何一方执行 `close()` 操作将产生挥手操作。

1. 第一次挥手(FIN=1，seq=x)：假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

2. 第二次挥手(ACK=1，ack=x+1)：服务端发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

3. 第三次挥手(FIN=1，seq=y)：服务器端准备好关闭连接，再次向客户端发送请求（结束连接），FIN 置为1。

   发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。

4. 第四次挥手(ACK=1，ack=y+1)：客户端接收到关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

其他：

**TCP KeepAlive** 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

### TCP、UDP区别

TCP：

- TCP 提供一种**面向连接的、可靠的**字节流服务。
- 在一个 TCP 连接中，仅有两方（一对一）进行彼此通信，广播和多播不能用于 TCP。
- TCP 使用校验和，确认和重传机制来保证可靠传输。
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复。
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制。

UDP：

- UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次。
- UDP 是**面向数据报**的传输。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。
- UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。
- UDP 支持多播和广播。

### TCP详解

- TCP段头部

![tcp-header](https://cescdf.com/image/tcp-header.png)

- 滑动窗口

TCP的滑动窗口是以字节为单位的（面向字节流），每个报文段在窗口中都有从低到高的序号。（发送方）A的发送窗口表示：在没有收到（接收方）B的确认的情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

- 流量控制

**流量控制**是为了控制发送方发送速率，保证接收方来得及接收。 <u>接收方</u>发送的<u>确认报文</u>中的<u>窗口字段</u>可以用来<u>控制发送方窗口大小</u>，从而影响发送方的发送速率。 将窗口字段设置为0，则发送方不能发送数据。

- 停止等待与超时重传

**停止等待协议**中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。

**连续 ARQ 协议** 指发送方维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。

- 拥塞控制（慢开始、拥塞避免、快重传、快恢复）

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

**慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即<u>由小到大逐渐增大发送窗口</u>，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。

**快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。有了 FRR，如果服务端接收到一个不按顺序的数据段（超过序号，比如已确认M2，下一个应该是M3，但是收到了M4），它会给客户端发送重复确认（确认收到M2）。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。简单来说，快重传和快恢复就是指<u>重复确认和立即重传</u>。

### OSI七层（五层）模型

![osi](https://cescdf.com/image/osi.jpeg)

### RPC与ARP协议

- RPC

RPC是会话层的概念，全称是远程过程调用（Remote Process Call）。其调用过程如下：

1. 建立基于TCP的通讯协议。
2. 解决寻址问题：发起调用方要告知底层的RPC框架，如何连接到被调用方的服务器（如主机或IP地址）以及特定的端口，方法的名称。
3. 通过序列化（内存中的参数的值要序列化成二进制）和反序列化（恢复为内存中的表达方式）进行数据的传递。
4. 

**rpc是一种概念，http是最常用的承载RPC的通信协议之一。**RPC的核心并不在于使用什么协议。RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这个调用的方法是部署哪里。 著名的 [gRPC]([grpc / grpc.io](https://link.zhihu.com/?target=http%3A//www.grpc.io/)) 使用的 http2 协议，也有如Dubbo一类的自定义报文的tcp协议。

- ARP

> 如果要在TCP/IP协议栈中选择一个**"最不安全的协议"**，那么我会毫不犹豫把票投给ARP协议。我们经常听到的这些术语，包括"网络扫描"、"内网渗透"、"中间人拦截"、"局域网流控"、"流量欺骗"，基本都跟ARP脱不了干系。大量的安全工具，例如大名鼎鼎的Cain、功能完备的Ettercap、操作傻瓜式的P2P终结者，底层都要基于ARP实现。
>
> ——[陈鑫杰](https://zhuanlan.zhihu.com/p/28771785)

**ARP（Address Resolution Protocol）即地址解析协议**， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。ARP整个完整交互过程仅需要两个包，一问一答即可搞定。

ARP在以太网内将请求包**以广播的形式**发送，交换机或WiFi设备（无线路由器）收到广播包时，会将此数据发给同一局域网的其他所有主机。（什么是广播？对于初学者而言，我们只需要知道，大部分的广播包，它们有一个共同特征：二层封装时目的MAC是全f（ffff.ffff.ffff）或三层封装时目的IP是全1（255.255.255.255）。）

发送方发送的请求广播包同时被其他主机收到，非目标收到之后（发现不是问自己）则丢弃。而占据目标IP地址的机器收到之后，根据请求包里面的信息（有自己的IP地址），判断是给自己的，所以不会做丢弃动作，而是返回ARP回应包。

简单来说ARP请求包的完整信息是：我的IP地址是IP1，MAC地址是MAC1，请问谁是占有IP2的PC2，你的IP2对应的MAC地址是多少？

### ICMP协议

ICMP的一个重要应用就是分组网间探测PING (Packet InterNet Groper)，用来测试两个主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。PING是应用层直接使用网络层ICMP的一个例子。它没有通过运输层的TCP或UDP。

### SMTP和IMAP、POP3协议

>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。
>
>Internet Mail Access Protocol（缩写为IMAP，以前称作交互邮件访问协议（interactive mail access protocol））IMAP是斯坦福大学在1986年开发的一种邮件获取协议。它的主要作用是邮件客户端（例如MS Outlook Express)可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。当前的权威定义是RFC3501。IMAP协议运行在TCP/IP协议之上，使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。

两者都是用于“邮件”的协议，**SMTP协议**属于TCP/IP**协议**簇，而**IMAP协议**运行在TCP/IP**协议**之上，使用的端口是143。**SMTP用于邮件发送/转发**，比如从Gmail的SMTP服务器发送到QQMail的SMTP服务器，而在用户客户端上，**读取邮件时用IMAP协议**，即收信方收到 QQ Mail的提醒，通过 IMAP 协议收取该封邮件。

另外，**POP3协议也用于读取邮件**，

>**[POP3](http://help.163.com/09/1223/14/5R7P6CJ600753VB8.html?servCode=6010376)**协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。
>
>**[IMAP](http://help.163.com/09/1223/14/5R7P6CJ600753VB8.html?servCode=6010376)**提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。

### 路由选择协议

**RIP是Routing Information Protocol（路由信息协议）的简称**，它是一种较为简单的内部网关协议（IGP，Interior Gateway Protocol），属于网络层。RIP使用UDP作为传输协议，端口号520。RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。RIP协议的特点是，仅和相邻路由交换信息、交换全部路由表信息、按固定的时间间隔交换。

**OSPF全称是开放最短路径优先OSPF (Open Shortest Path First)**，也属于内部网关协议，将协议报文直接封装在IP报文中，协议号89，由于IP协议本身是不可靠传输协议，所以OSPF传输的可靠性需要协议本身来保证。OSPF最主要的特征就是使用分布式的链路状态协议(link state protocol)，而不是像RIP那样的距离向量协议。它的特点是：向本自治系统中所有路由器发送信息、发送的信息就是与本路由器相邻的所有路由器的链路状态、只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。

### HTTP1.1报文结构

HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：请求行/状态行、请求头、消息主体。

一个请求行的例子是

```http
GET /data/info.html HTTP/1.1
```

### HTTP常见首部

一个GET请求首部如下：

```http
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1
Cache-Control: no-store
```

POST：

```http
POST / HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive
Keep-Alive: timeout=5, max=100
```

### HTTP长连接

- HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。
- HTTP 长连接不可能一直保持，例如 `Keep-Alive: timeout=5, max=100`，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。
- HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。

### 状态码与304

见[HTTP状态码](https://cescdf.com/blog/202103/http-state-code-summary)

- 304

`304 Not Modified`表明 文件未修改，可以直接使用缓存的文件。

> 采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部时，可能会返回304 Not Modified.

### GET、POST、PUT区别

- GET参数通过URL传递，POST放在Request body中。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET 请求中有非 ASCII 字符，会在请求之前进行转码，POST不用，因为POST在Request body中，通过 MIME，也就可以传输非 ASCII 字符。
- PUT请求会修改并储存资源，而且是幂等的，即说如果几个PUT请求相同，最后的请求会覆盖前面的请求，而POST请求不是幂等的，仅用于数据传输。

### HTTP2

见[HTTP2](https://cescdf.com/blog/202103/reading-http2-basic)

HTTP2是基于二进制帧的协议，分为两个层：分帧层和数据层（http层）。

- 二进制协议：分帧层传输基于帧的二进制协议。
- 首部压缩：深度压缩。
- 多路复用：请求和响应在一个通道上，所有请求都是通过一个 TCP 连接并发完成
- 加密传输：加密。

### Hash函数与加密算法

- 哈希函数

哈希，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。

- MD5

  MD5产生一个128位的散列值，大概过程是

  1. 数据填充，使得`length mod 512 = 448`，补充第一位为1，其余为0。
  2. 数据分组，从4个初始常量开始分组做4轮主循环。
  3. 把四个输出按低内存到高内存排列起来，共128位。

  现在看来，MD5已经较老，散列长度通常为128位，随着计算机运算能力提高，找到“碰撞”是可能的。因此，在安全要求高的场合不使用MD5。

- SHA256

  对于任意长度的消息，SHA256都会产生一个256位的哈希值，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常有一个长度为64的十六进制字符串来表示，其中1个字节=8位，一个十六进制的字符的长度为4位。

  SHA256会初始化8个哈希初值常量和算法中会用到的其他64个常量，基本思路也是消息填充+分组运算后合并。

- 公钥、私钥与数字签名

  对称加密是指双方持有相同的密钥进行通信，优点是速度快，缺点是密钥传递不安全。非对称加密的特点是：公钥加密的数据、只能用私钥解密；私钥加密的数据，只能用公钥解密，缺点是速度相比对称加密来说较慢。

  - 客户端给服务端发送数据，只需要用到服务端的公钥加密，这样服务器可以用私钥解密；
  - 服务端给客户端发送数据，需要先用hash函数，生成信件的摘要（Digest），使用私钥对摘要加密，生成数字签名（Signature），将数字签名和消息体一并发送给客户端；客户端使用公钥解密签名，得到（Digest），再对比消息体Hash后的摘要，就可以知道消息是否被篡改了。然而这种方法是有缺陷的，因为这个公钥是不被信任的，任何人都可以用自己的公钥加密并伪造成是服务器的公钥。
  - "证书中心"（certificate authority，简称CA）负责对公钥做认证。证书中心用自己的私钥，对服务端的公钥和其他一些消息一起加密，生成"数字证书"（Digital Certificate）。服务端拿到数字证书后，同时将自己的签名和数字证书一并发送给客户端，客户端收到后，用CA的公钥解开数字证书，就可以拿到服务端真实的公钥了，然后就能证明"数字签名"是否真的是服务端签的。这里引入证书中心的目的，就是确保公钥是来自服务端的了。

### HTTPS

![https](https://cescdf.com/image/https.jpeg)

注意点：

- 首先，服务端的公钥发送给客户端的同时，也发送数字证书，客户端通过CA的公钥解开数字证书，因此可以确定公钥来自服务端。
- 之后，通信过程中用到的对称加密密钥，由客户端产生随机数，通过服务端的公钥加密，发送给服务端的，这样可以确保只有持有私钥的服务端可以得到密钥。
- 所以说，HTTPS同时利用了对称加密和非对称加密的技术。

在接下来的会话中，服务器和客户端将会使用最后生成的随机码密钥进行对称加密，保证通信过程中信息的安全。

可参考[阮一峰](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)。

### session, cookie和token

在http头部设置`HttpOnly`可以防止JS脚本读取cookie。

**HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息**）：每个请求都是完全独立的。维护一个状态需要通过 cookie 或者 session 去实现。

**cookie 存储在客户端：** cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

**cookie 是不可跨域的：** 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。

**session 是基于 cookie 实现的，session 存储在服务器端；sessionId 会被存储到客户端的cookie 中**，客户端的第一次请求会被返回一个sessionId，之后的请求都会在cookie中带上这个sessionId。

**sessionID 是连接 Cookie 和 Session 的一道桥梁**，大部分系统也是根据此原理来验证用户登录状态。

Cookie和Session的区别：

- **安全性：** Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- **存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- **有效期不同：** Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- **存储大小不同：** 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

关于token，更多的信息详见这篇[掘金博客](https://juejin.cn/post/6844904034181070861)。

关于JWT，见阮一峰老师的[博客](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)。

### localStorage，sessionStorage

**HTML5 中的 Web Storage 包括了两种存储方式：sessionStorage 和 localStorage。** sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据也随之销毁。localStorage 用于存储一个域名下的需要永久存在在本地的数据，这些数据可以被一直访问，直到这些数据被删除。因此sessionStorage 和 localStorage 的主要区别在于他们存储数据的生命周期，sessionStorage 存储的数据的生命周期是一个会话，而 localStorage 存储的数据的生命周期是永久，直到被主动删除，否则数据永远不会过期的。

### DNS解析流程

顺序：

1. 浏览器缓存
2. 用户计算机系统Hosts文件DNS缓存
3. 路由器缓存
4.  ISP（互联网服务提供商）DNS缓存
5. 根域名服务器（全球仅有13台）
6. 顶级域名服务器（递归地查找二级域名、三级域名或子域名）
7. 主域名服务器

本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。

### WebSocket

[WebSocket](http://websocket.org/) 是一种网络通信协议，它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于[服务器推送技术](https://en.wikipedia.org/wiki/Push_technology)的一种。

其特点包括：

（1）建立在 TCP 协议之上，服务器端的实现比较容易。

（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

（3）数据格式比较轻量，性能开销小，通信高效。

（4）可以发送文本，也可以发送二进制数据。

（5）没有同源限制，客户端可以与任意服务器通信。

（6）协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

**WebSocket是HTML5出的东西（协议）**，也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）

Websocket是基于HTTP协议的，或者说**借用**了HTTP的协议来完成一部分握手，如下：

```http
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

Websocket只需要经过**一次HTTP请求**，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）。Websocket只需要**一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中**，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。

对于不支持Websocket的机器，可以通过 long poll 和 ajax 轮询来 **模拟出类似的效果**。

WebSocket与传统HTTP有如下好处。

- 客户端与服务器端**只建立一个TCP连接**，可以使用更少的连接。
- WebSocket服务器端可以推送数据到客户端，实现**双向通信**。
- 有更**轻量级的协议头**，减少数据传送量。

### CDN是什么

CDN的全称是Content Delivery Network或Content Ddistribute Network，即内容分发网络。

最简单的CDN网络由一个DNS服务器和几台缓存服务器组成：

1. 用户访问URL，经过本地DNS系统解析，DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器。
2. CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。
3. 用户向CDN的全局负载均衡设备IP发起内容URL访问请求。
4. CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
5. 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。
6. 全局负载均衡设备把服务器的IP地址返回给用户。
7. 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

国内访问量较高的网站、<u>直播、视频</u>平台，均使用CDN网络加速技术。

### 缓存

大致分为强缓存和协商缓存，见[掘金](https://juejin.cn/post/6947936223126093861)。

### cache-control缓存机制

```http
Cache-Control: no-cache
Cache-Control: private
Cache-Control: public
Cache-Control: max-age=31536000
Cache-Control: must-revalidate
```

`public`缓存表示可以被任何中间人缓存，比如CDN、代理。

### 安全

分隔代码和数据是解决注入攻击的常见通用手段。

- SQL注入

  Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。

- XSS攻击

  Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。XSS攻击的形式包括：通过 document.cookie 盗取 cookie中的信息；使用 js或 css破坏页面正常的结构与样式；流量劫持（通过访问某段具有 window.location.href 定位到其他页面）等。

  根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。

  [美团前端安全系列（一）：如何防止XSS攻击](https://tech.meituan.com/2018/09/27/fe-security.html#:~:text=%E4%BB%80%E4%B9%88%E6%98%AFXSS,%E7%AD%89%EF%BC%8C%E8%BF%9B%E8%80%8C%E5%8D%B1%E5%AE%B3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E3%80%82)

- CSRF攻击

  CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

  [美团前端安全系列（二）：如何防止CSRF攻击](https://tech.meituan.com/2018/10/11/fe-security-csrf.html#:~:text=%E4%BB%80%E4%B9%88%E6%98%AFCSRF,%E6%9F%90%E9%A1%B9%E6%93%8D%E4%BD%9C%E7%9A%84%E7%9B%AE%E7%9A%84%E3%80%82)

- 流量劫持（DNS、HTTP）

  流量劫持划分成3大部分：**DNS劫持、数据劫持、劫持监控。**

  DNS劫持或域名劫持是互联网一种攻击方式，通过攻击 DNS服务器 或者 伪造DNS 服务器方法，把目标服务器网站域名解析到错误地方，让用户无法正常访问真正的地址。常见的污染 DNS 方式有：篡改 Hosts 文件；污染中间链路设备（路由器等）；修改 UDP内容，影响 DNS查询的结果；入侵 DNS服务器（成本高）。

  数据劫持最基本针对明文传输的内容发生。用户发起 HTTP请求，服务器返回页面时候，经过中间的运营商网络，页面内容的篡改或者内容加塞，强行插入弹窗或者广告。

- 钓鱼网站

- DoS/DDoS 

  **SYN 攻击**指的是，攻击方在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有：缩短超时（SYN Timeout）时间、增加最大半连接数等。



### 综合题：页面性能

先随便打一些：

- 使用CDN
- 使用懒加载`const xxx =()=>import('./components/...')`
- 减少监听器个数，使用事件委托
- 使用资源压缩
- 非核心资源的异步按需加载
- 加载过程使用suspense提升用户体验

看完[这篇文章](https://mp.weixin.qq.com/s/CSrzs5oBzHQKuVM3rCjkOQ)之后重新整理这一小节。

### 综合题：输入URL到页面显示的全过程

先来一个简化版的：

![url-to-browser](https://cescdf.com/image/url-to-browser.png)



### 参考

- [计算机网络系列汇总](https://leetcode-cn.com/circle/discuss/KGfjHI/)

